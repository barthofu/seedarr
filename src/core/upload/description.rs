use crate::core::naming::TechnicalInfo;

/// Builds a Markdown description for tracker upload.
///
/// Keep this stable & deterministic: it should always rebuild from Radarr + MediaInfo.
pub fn build_markdown(
    title: &str,
    year: Option<u16>,
    cover_url: Option<&str>,
    overview: Option<&str>,
    scene_name: &str,
    tech: &TechnicalInfo,
) -> String {
    let mut md = String::new();

    md.push_str("# ");
    md.push_str(title);
    if let Some(y) = year {
        md.push_str(&format!(" ({y})"));
    }
    md.push_str("\n\n");

    md.push_str("**Release:** ");
    md.push_str(scene_name);
    md.push_str("\n\n");

    if let Some(url) = cover_url {
        let url = url.trim();
        if (url.starts_with("https://") || url.starts_with("http://")) && !url.is_empty() {
            let alt = escape_html_attr(title);
            let src = escape_html_attr(url);
            md.push_str(&format!("<img src=\"{src}\" alt=\"{alt}\" />\n\n"));
        }
    }

    if let Some(ov) = overview {
        let ov = ov.trim();
        if !ov.is_empty() {
            md.push_str("## Synopsis\n\n");
            md.push_str(ov);
            md.push_str("\n\n");
        }
    }

    md.push_str("## Media\n\n");

    // Video
    let mut video_bits = Vec::new();
    if let Some(res) = &tech.resolution {
        video_bits.push(res.clone());
    }
    if let Some(v) = &tech.video_codec {
        video_bits.push(v.clone());
    }
    if let Some(bd) = &tech.bit_depth {
        video_bits.push(bd.clone());
    }
    if tech.dv {
        video_bits.push("DV".to_string());
    }
    if tech.hdr && !tech.dv {
        video_bits.push("HDR".to_string());
    }

    if !video_bits.is_empty() {
        md.push_str("- **Video:** ");
        md.push_str(&video_bits.join(" "));
        md.push('\n');
    }

    // Audio
    let mut audio_bits = Vec::new();
    if let Some(a) = &tech.audio_codec {
        audio_bits.push(a.clone());
    }
    if let Some(ch) = &tech.audio_channels {
        audio_bits.push(ch.clone());
    }
    if !tech.audio_languages.is_empty() {
        let langs = tech
            .audio_languages
            .iter()
            .cloned()
            .collect::<Vec<_>>()
            .join(", ");
        audio_bits.push(format!("langs: {langs}"));
    }
    if tech.has_vfi {
        audio_bits.push("VFI".to_string());
    }
    if !audio_bits.is_empty() {
        md.push_str("- **Audio:** ");
        md.push_str(&audio_bits.join(" "));
        md.push('\n');
    }

    // Subtitles
    if !tech.subtitle_languages.is_empty() {
        let langs = tech
            .subtitle_languages
            .iter()
            .cloned()
            .collect::<Vec<_>>()
            .join(", ");
        md.push_str("- **Subtitles:** ");
        md.push_str(&langs);
        md.push('\n');
    }

    md.push_str("\n---\n\n");
    md.push_str("_Generated by seedarr from Radarr + MediaInfo._\n");

    md
}

fn escape_html_attr(s: &str) -> String {
    // Minimal escaping for HTML attributes.
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}
